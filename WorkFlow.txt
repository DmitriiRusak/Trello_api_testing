Маинд мап по cucumber steps расположен в Miro -> https://miro.com/app/board/uXjVIjAyXL0=/

На текущий момент в проекте реализован механизм логирования в 2 классах: ApiClient, ListeningConfig
Надо почитать свои заметки по логированию. Возможно целесообразно наличие только одного механизма

По сути ListeningConfig кодирует отчёт в Alure.

------------------------------------------------------------------------------------------------------
1) Таак немного разобрался с логоми. Получается, что логи не работали из-за того, что в проекте было 2 конфигура-
ционных log4j2 файла, один с расширением .properties, один с .xml. Тот, что с пропертис я закоментил, но это
всёравно было ошибкой, файл должен быть один в проекте.

2) Разобрался почему не работает тест листенер от TestNG - потому, что он для этого не подходит. Оказывается у
Cucumber-a есть свой аналог. И называется он event listener, его и надо разобраьт, в место того, что просто
расстовлять логи в step definishn

3) Большое количество логов было, и долго не мог найти причину, где они закодированы (реализованы), окозалось,
что всё дело в requestSpecification, была просетана выводить все логи.

На завтра:
- Разобратся с event listener - ом, возможно его можно использовать в качестве TestNg listener
- Расставить логи в проекте
- Подключить запись логов в файл
-----------------------------------------------------------------------------------------------------
27.07.2025

- Вроде бы можно использовать TestNG TestListeners c Cucumber через testNg.xml конфигурационный файл.
Да можно но в конфигурационный файл можно подставить в качестве теста минимальную единицу это класс,
т.е. раннер от Cucumber-а. Так как конфигурационный TestNg.xml файл может в себе содержать .java файлы,
другими словами в него нельзя подставить feature файл. Ну и что? А то, что в раннере нет никаких тестов,
тесты сами (Sceanrio) расположены в feature файле. Получается, что коомпилятор не знает названия тестов
которые он воспроизводит (ранит) всё, что он знает это название класса, т.е. название раннера. А привязку
сценарио к раннеру мы делаем за щёт тега, получается, что раннер знает и названия тестов и прочую рантайм
инф о тесте, а коомпилятор нет. И что? А то, что в случае например падения сценария мы не сможем вывести
в логах даже название упавшего теста. Максиму это название упавшего раннера, а в раннере может быть
сколько угодно Scenario-в прикреплённых тегом, из которых мы никак не можем понять, что упало. Вернее
можем, благодаря логам кукумбера.

Cucumber Event listener - есть и его надо потренить
Также нарисовался Cucumber.properties файл, надо разобратся
---------------------------------------------------------------------------------------------------
28.07.2025

Разобрал ивент листенер, он здесь не такой гибкий, как в тестндж, и из-за хорошего родного
логирования, использовать этот подход для логов не вариант, только всё испортиш,
Единственно можно добавить log4j для записи логов в файл, чтобы отслеживать динамику.

Если пользоватся раннером + установить HTML отчёт в cucumberOptions и с помощью атрибута plugin,

@CucumberOptions(features = "src/test/resources/cucumberFeatures",
                glue = {"api.cucumber.stepDefinition","api.cucumber.runners"},
                plugin = {"pretty", "api.utils.CucumberEventListener", "html:target/cucumber.html"},
                tags = "@Smoke")

то логи сторонние просто мешают, они не информативны вообще. Отчёт изумительный.
Также с помощью cucumber.properties можно указать, чтобы отчёт сохранялся в облаке на 24 часа.

cucumber.publish.enabled=true
и на этот отчёт можно просто дать ссылку.

Opanki, poxozze chto logi mozzno podklychit i spomoschy hooks, nado proverit.
Да с помощью хукс, это окозалось намного быстрее и понятней но

как получить сущность step-a из Scenario, чтобы узнать его название.?????????????????? и записать в лог файле.
Другими словами Самая меньшая сущность к которой можно обратится это Scenario, но если оно упало то знать, что оно
упало не достаточно информативно, даже когда тестируеш API, а, что если это будет UI и надо сделать скриншот.
Не хватает сущности именно step-a из сценарио.
------------------------------------------------------------------------------------------------------------------
30.07.2025
Дополнительное логирование с помощью библиотеки log4j всё таки нужно оставить с записью логов в файл. Но надо:
- Попробовать получить сущность степа в хуксах, для логов.

Таак, будем разбиратся!!!
Похоже, что если использовать ивент листенер для записи логов в файл, то нет никакого конфликта с логоми
которые идут по умолчанию от кукумбера. Вернее не так. Логи попрежнему перемешиваются и порядок их выполнения
хаотичен, это происходит когда добовляеш свои логи в хукс, BeforeAll или AfterAll не отображаются в консоли в соответствующее
время. Может например выполнится (речь про консоль) сначала AfterAll а потом логи от log4j2
Но всё меняется, если log4j2 записывать в файл и не показывать в консоли. Консоль получается чистая, а логи по умолчанию
достаточно информативны, а в файл логи идут строго в том порядке как они расставлены в ивент листенере.
И ивент листенер даёт возможность получить сущность степа с его результатами, ошибками, названием и пр., что круто,
для этого используют некий pico container.

!!! Возможно если расставить логи только в хуксах и тоже использовать запись в файл, всё будет хорошо, но не понятно
откуда брать сущность о TestStep-e. Scenario там есть, а вот степов нет. Соответственно логи получаются менее
информативны, так как у нас нет шага в сценарии который упал, нет ошибки по которой шаг упал. Минимальная
единица это сценарий, сценарий упал и, что, что дальше, почему упал ... Наличие степа намного лутше.
-----------------------------------------------------------------------------------------------------------
01.08.2025
- Надо сделать логи для рестАшурд части проекта, чтобы записывала в файл. Врядли удастся разделит на разные файлы, имеется ввиду
месторасположение логов, поэтому надо, чтобы в рамках одного файла было понятно какие логи откуда, возможно
стоит рассмотреть логи с регресса для рест ашурд тестов.

Почти все тестовые классы сьехали и фэйлятся. Увидеть причину нельзя, так как я отключил логи по умолчанию. А кастомные
логи я сетаю в Тестлистенере, который работает с ТЕСТАМИ. Но в теставых классах есть методы которые выполняют HTTP запросы
до самих тестов используя туже инфраструктуру, что и тесты. И если ошибка в тех методах и они выполняются до тестов,
то ошибка никуда не выводится.
Решение: поставить лдоги в класс который выполняет HTTP запросы/ответы, это либо Base Service or ApiClient.

В обоих фреймворках: RestAssured или Cucumber, HTTP запросы всегда выполняет только одна сущность - ApiClient.
Возможно будет логично составить логи в этом классе.
------------------------------------------------------------------------------------------------------------
03.08.2025
-Логи из тестлистенера не отрабатывают ы методах помеченные как @Before... от TestNG, что делать:

1) Можно разместить логи в той сущности которая делает HTTP запросы/ответы. Но как узнать какой
метод вызвал этот HTTP запрос? А для чего? Для того, чтобы знать место т.е. название метода который упал.

2) Можно разместить логи в каждом методе, каждого сервиса. Но это ооочень долго и трудно поддерживать

3) Можно разместить логи в тех @Before и @After методах, их как бы меньше, а тесты закроет листенер.

В результате решил разместить логи в тех методах от сервисов которые участвуют в @Before, @After.
Почему не прямо в @Before, @After? Потому, что методы которые используются в @Before, @After повторяются, придётся
повторять одни и теже логи. Так хотябы повторений нет.
P.s. по итогу мне это тоже не понравилось, так как непончтно по какому принципу расставляются логи, в некоторых
методах сервисов они есть, в некоторых нет. Поддерживать и тем более расширять тестовый проект очень трудозатратно.
Оставляю логи только в ApiClent. До тестов там видно, что выполняются запросы, если запрос упал то можно просто
сопаставить поочерёдность наличия методов в @Before, @After и их выполнение, в тестах которые пропускаются (skiped)
есть название тестового класса и название теста. Получается менее информативно но логически понятно где/что/какработает
и почему там находится.
---------------------------------------------------------------------------------------------------------------------
09.08.2025
Переделал все ассерты в RestAssured части, те что были только на проверку статус код 200, добавил ещё проверку на поле
Переделал логи из cucumber части, так как для информативных логов во время выполнения rest assured части мало было
тест листенера, так как есть методы выполняемые Before, After аннотациями которые также делают HTTP ЗАПРОСЫ для подготовки
preconditions к предстоящим тестам и эти методы тоже могут сломатся, и так как они не являются тестами они не отслеживаются
тестНДЖ тестлистенером, соответственно и логи на них не создаются и не понятно, что, где упало.
Пришлось добавить логи в апиклиенте и отредоктировать. Но после этого логи на кукумбер сьехали, так как механизм
работы уровня сервис один, т.е., Апи клиеньт. Получилось, что для кукумбера апиклиент выводил логи и ивент листенер,
была неразбериха.
Решение: сделать в апиклиенте проверку на стек имеющихся в рантайме классов и если там есть тестовые классы из
api.test то значит выполняется часть фреймворка с apitest-ами, т.е. не кукумбер, соответственно логи выводим. Если
классов с таким названием нет, соответственно выполняется кукумбер часть фреймворка, логи из апиклиента не выводим,
они мешают ивент листенеру, который хорошо справляется.
Что дальше?
- Можно сделать несколько .xml ранеров для API части, что-то типа модульного, с возможностью ранить любой модуль/класс
и всех API тестов. По этому же пути можно сделать и любой тип тестирования, например E2E, в .xml файле создать тег
Test и накидать туда методов (с указанием класса) которые должны учавствовать.

Теперь надо разобратся с кукумбер раннерами
Надо както уточнять в логах по кукумберу что за раннер воспроизводится
Таак ещё один момент нарисовался, в кукумбер сценарии если он падает то не понятно из-за чего, нет URL- a,нет возможности
понять причину. Это должно быть при ошибки как минимум.

В общем ивент листенер это ерунда для кукумбера, он сначала делает по факту все сценарии и только потом делает ивент листенер
после всего рана. Cоответственно все переменные отвечающие за понимание причины ошибки переинициализируются по нескольку раз.
В общем встал выбор: либо красивый вывод с названиями степов - что красиво, когда всё хорошо. Но если что то упало то видно
где упало (степ) но нет причины, ты не можеш понять причину. Либо делать свои переменные, инициализировать их после
каждого степа и после каждого степа, используя хукс, выводить их. Нет сущности степа, т.е. нет названия степа, но так
как каждый степ = HTTP запрос, то в логах легко +- ориентироватся какой степ по очереди выполнялся, а вот проинициализированные
переменные достаточно хорошо описывают подение и причину не трудно увидеть.
Оставляю всё же версию с хукс.
----------------------------------------------------------------------------------------------------------------------------------
Надо разобратся с @Before... методами, так как есть разная логика. Вроде с помощью тегов можно привязывать сценарии к
этим методам. На тот случай если для разных сценариев нужны разные хукс.

ООО!!! Случяйно увидел, что в некоторых степах есть по нескольку HTTP запросов, такое в логах не отследить, надо принять за некий
стандарт один степ = один HTTP запрос. Нет сделал по другому, так, чтоб в логах визуально было видно степ с множеством
(если они там есть) HTTP запросов. Получается пришлось вернутся к кукумбер ивент листенер т.к. там было название степа +
ошибка по которой упал степ. Если это не сделать, то логи которые заточены только на ApiClient-е не видят что тест падает
например по ассерту, это может увидеть сущность сценария в хуксах, но она видит, что сценарий упал, а почему оно не знает,
пришлось реанимировать кумбер ивент листенер, только он знает почему и на каком шаге всё упало. Можно конечно было расставить
логи по тестам но это очень много логов и поддерживать было бы сложно и маштабировать.

Получается для кукумбера за логи отвечают: Runner (c хуксами), ApiClient, EventListener.
Для RestAssured - ApiClient, ServiceWorkShop, TestListener

Вся сложность для РестАшурд с логами заключалась в том, что использовать только тест листенер не удастся, так как в тестовых
классах есть методы помеченные аннотацией бифор класс и афтер класс которые также мользуются арсеналом апиклиента и
сервисов, но так как эти методы не тесты (они как прекондишн) то и если чёт упало там, то тестлистенер об этом не знает.
он отслеживает только тесты. Поэтому интегрируя логи надо покрывать конфигурационные методы и тесты 2 мя механизмами.

С кукумбером сложность заключалась в логике работы ивент листененра, который хоть и придерживается той же логики, что и ТестНдж,
но сама его работа спецефична и отличается. Главное отличие - ивентлистенер выводит инф. после того как пройдёт всё воспроизведение
(после всего рана)и только потом он выведет логи.Т.е. нет токого степ прошол логи получи, это очень запутывает, особенно
учитывая тот факт, что у степа может быть много HTTP запросов/ответов и если степ упадёт ивентлистенер скажет - степ упал
и выведет ошибку и строку в коде, где степ расположен в сценарии. Но URL или Response.asPrityString(), вывести не сможет,
yрл у него будет уже сто раз перезаписанный, так как после падения степа кукумбер берёт и выполняет след. сценарий.
А логи выдаст после всего рана. Соответственно значения в этих переменных (переменные то унего есть) будут хранить не
актуальные значения. Пришлось искать некий компромис подключая логи опять же в АпиКлиент теи самым получать актуальные
YRL, но ивентлистенер знет об падениях самих сценариеа (ассертов), поэтому его тоже интегрируем. Сами логи при этом
идут сначала URL всех HTTP запросов, а после этого кукумбер ивент листенер говорит что прошло, что не прошло и почему.
Другими словами ивеннЛистенер не знает HTTP запросы, так как перезаписывает свои переменные.

Что дальше? Аллюр рипорт? Для РестАшурд части можно, но для кукумбера с его HTML в cloud может и не стоит.
По рестАшурду - расставить аннотации в тестах.И сё?
-----------------------------------------------------------------------------------------------------------------------------------
В общем по аллюру
Он интегрирован с помощью:
1) - @Step аннотаций на уровне сервисов, что создаёт секцию Execution в репорте c пошаговым выводом
той информации, что была указана в @Step, если тест фэйлится, то видно на каком шаге - очь круто.
2) - B самих тестах использован аллюровские аннотации типа @Description, Severity + аннотации на уровне тестовых классов @epic,feature...
3) - Для прикреплённых файлов request/response в спецификацию был добавлен фильтр - .addFilter(new AllureRestAssured())...
-----------------------------------------------------------------------------------------------------------------------------------


